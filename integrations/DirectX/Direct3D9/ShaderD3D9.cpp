/****************************************************************************
This source file is (c) Teardrop Games LLC. All rights reserved. 
Redistribution and/or reproduction, in whole or in part, without prior
written permission of a duly authorized representative of Teardrop Games LLC
is prohibited.
****************************************************************************/

#include "stdafx.h"
#include "ShaderD3D9.h"
#include "Gfx/Material.h"
#include "Gfx/Connection.h"
#include "Gfx/Attribute.h"
#include "Gfx/MaterialExpression.h"
#include <sstream>
#include <set>
#include <assert.h>

namespace Teardrop {
namespace Gfx {
namespace Direct3D9 {

Shader::Shader(IDirect3DDevice9* device, Material* mtl)
	: Gfx::Shader(mtl)
	, mDevice(device)
	, mVS(0)
	, mPS(0)
	, mFX(0)
	, mTechnique(0)
	, mTechniqueShadowCast(0)
	, mTechniqueShadowRecv(0)
{
	assert(mDevice);
}

Shader::~Shader()
{
}

bool Shader::initialize()
{
	// build and compile vertex and pixel shaders
	if (!mSource.length()) {
		// generate source from material definition/expressions

		// first the common parts
		mSource.append(HLSL_COMMON);

		// perform a topological sort on the shader expressions, so that we can order 
		// their invocation in order, as well as collect their definitions
		mMaterial->sortExpressions();

		// then functions for each expression in the shader; we can iterate the sorted
		// expressions and put out definitions for each unique expression ClassDef
		std::set<const Reflection::ClassDef*> uniqueExprs;
		int exprCount = mMaterial->expressionCount();
		MaterialExpression** expressions = mMaterial->sortedExpressions();

		std::stringstream defs;
		for (int i=0; i<exprCount; ++i) {
			MaterialExpression* expr = expressions[i];
			const Reflection::ClassDef* classDef = expr->getDerivedClassDef();
			if (uniqueExprs.find(classDef) == uniqueExprs.end()) {
				uniqueExprs.insert(classDef);

				// and then generate the definition for this expression
				expr->appendDefinition(MaterialExpression::SHADER_HLSL, defs);
			}
		}

		std::string defStr(defs.str());
		mSource.append(defStr.c_str());

		// then generate the function calls
		typedef std::map<const Attribute*, std::string> AttrToVarName;
		AttrToVarName names;

		// go through all connections and form this map
		int nConnections = mMaterial->connections(0, 0);
		std::vector<Connection*> connections(nConnections);
		mMaterial->connections(&connections[0], nConnections);

		// variable names should be based on the name (type) of the expression
		// that owns the "from" (output) attr; for uniqueness, we'll just assign
		// monotonically-increasing ordinals to each connection
		int ord = 0;
		for (int i=0; i<nConnections; ++i) {
			std::stringstream ss;
			Gfx::Attribute* out = connections[i]->output();
			MaterialExpression* me = out->mParent;
			ss << me->getDerivedClassDef()->getName() << '_' << ord++ << '_' << out->mName;
			std::string tmp(ss.str());
			names[connections[i]->output()] = tmp;
			names[connections[i]->input()] = tmp;
		}

		// then generate the function calls...
		std::stringstream calls;
		for (int i=0; i<exprCount; ++i) {
			MaterialExpression* expr = expressions[i];

			// our input attributes are someone else's output attributes, so collect their names
			// into a std::vector of strings
			const MaterialExpression::Attributes& inputAttrs = expr->inputAttributes();
			std::vector<std::string> inputs(inputAttrs.size());

			int nameIdx = 0;
			for (size_t j=0; j<inputAttrs.size(); ++j) {
				// find this attribute's name in the connection map
				const Attribute* attr = &inputAttrs[j];
				AttrToVarName::iterator name = names.find(attr);

				std::string tmp("float(0)");
				std::string* arg = &tmp;

				if(name != names.end()) {
					// then use the generated name
					arg = &(name->second);
				}
				else {
					// make sure the attribute is actually optional, and if so,
					// use the attribute's default value
					assert(attr->mRequired == Attribute::Optional);

					if (attr->mRequired == Attribute::Optional)
						tmp = attr->mDefault;
				}

				inputs[nameIdx++] = *arg;
			}

			// then we can generate the code for this call
			expr->appendCall(
				MaterialExpression::SHADER_HLSL,
				i,
				inputs,
				names,
				calls
				);
		}

		std::string callStr(calls.str());
		mSource.append(callStr.c_str());
	}

	return true;
}

bool Shader::destroy()
{
	// release vertex and pixel shaders, if initialized
	if (mVS) {
		mVS->Release();
		mVS = 0;
	}

	if (mPS) {
		mPS->Release();
		mPS = 0;
	}

	return true;
}

void Shader::apply()
{
	assert(mDevice);

	// check to see if VS/PS need initialized
	if (!mVS && !mPS) {
		initialize();
	}
}

const char* Shader::HLSL_COMMON =
"// This shader is autogenerated\n"
"\n"
"typedef float4 RGBA;\n"
"typedef float3 RGB;\n"
"\n"
;

} // Direct3D9
} // Gfx
} // Teardrop
